schema: spec-driven

context: |
  # Project Context

  ## Purpose

  Ã€ la carte is a multi-platform rating and sharing system for consumables such as cheese, gin, wine, beer, coffee, etc. Its primary goal is to provide a comprehensive platform for users to rate and share their experiences with various consumables.

  ## Tech Stack

  - **API:** Go (>=1.21), Gin, GORM, MySQL (8.0+), Google OAuth 2.0, JWT tokens
  - **Client:** Flutter SDK (>=3.27), Riverpod, Google Sign-In (google_sign_in package), Cross-platform OAuth (Web, Android, Desktop)
  - **Admin:** Next.js, TypeScript (strict, no `any`), NextAuth.js for Google OAuth integration
  - **Infrastructure:** Google Cloud Run, Cloud SQL (MySQL), Docker & Docker Compose
  - **CI/CD:** GitHub Actions, Docker Hub, Snapshot builds for PRs (Docker images for API/Admin, APK for Client)
  - **Release Automation:** Conventional Commits, versio, GitHub Actions
  - **Monorepo Tools:** commitlint, husky Git hooks

  ## Project Conventions

  ### Code Style

  Code style preferences are implicitly derived from the chosen frameworks and languages.

  - **Go (API):** Follows [Effective Go](https://golang.org/doc/effective_go.html) and uses `gofmt` for formatting. Emphasizes meaningful variable names and explicit error handling.
  - **Dart/Flutter (Client):** Follows [Effective Dart](https://dart.dev/guides/language/effective-dart) and uses `dart format` for formatting. Utilizes Riverpod for state management and adheres to existing widget patterns.
  - **TypeScript/Next.js (Admin):** Follows [Next.js best practices](https://nextjs.org/docs) and uses TypeScript strictly (avoiding `any`). Relies on provided UI components and existing page patterns.
  - **General Principles:** Follow existing patterns, adhere to DRY (Don't Repeat Yourself), write self-documenting code, add comments only for complex logic, and prioritize readability over cleverness.

  ### Architecture Patterns

  The project utilizes a monorepo structure, housing multiple applications:

  - A Go REST API (`apps/api`)
  - A Flutter mobile/web client (`apps/client`)
  - A Next.js admin panel (`apps/admin`)

  This architecture promotes code sharing and streamlined development across different platforms while maintaining distinct application boundaries. The monorepo also includes:

  - `.github/workflows/`: Contains CI/CD pipelines (`pr-snapshot.yml`, `cleanup-snapshots.yml`, `version.yml`, `release.yml`).
  - `.versio.yaml`: Configuration for versio version management
  - `commitlint.config.js`: Rules for commit validation.
  - `.husky/`: Git hooks.
  - `docker-compose.yml`: Root orchestration for local development.
  - `package.json`: Root package.json for monorepo tooling.
  - `docs/`: Consolidated documentation.

  ### Testing Strategy

  There is currently no formal testing strategy defined (unit, functional, or end to end)

  ### Git Workflow

  The project employs a Git workflow centered around **Conventional Commits**.

  - **Branching Strategy:** Feature branches are used for development, which are then merged into `master`.
    - **Branch Naming Convention:** `feat/your-feature-name`, `fix/bug-description`, `refactor/`, `docs/`, `chore/`.
  - **Commit Messages:** Conventional Commits format enforced by commitlint and husky git hooks. The `commitlint.config.js` defines rules such as requiring a scope and using sentence-case for the subject.
    - **Valid types:** `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
    - **Valid scopes:** `api`, `client`, `admin`, `deps`, `ci`, `docs`, `release`
  - **Versioning Strategy:** The project uses automated versioning with independent releases for each application. Conventional commits drive versioning, with `versio` analyzing commits to determine version bumps. Tags are generated by application following the convention `app_name`-v`version` with `version` following semantic versioning.
  - **Release Process:** Releases are fully automated using `GitHub Actions`. Conventional commits trigger `versio`, which determines version bumps for each application independently based on commit types. When PRs are merged to master, versio creates Git tags directly for each application following SemVer conventions and updates respective `CHANGELOG.md` files. Build workflows are then triggered on each tag to build the required application and create GitHub releases with links to the app's `CHANGELOG.md` as well as attach built APK for the `client` app.
  - **Prerelease Versions:** Every PR commit automatically generates snapshot versions for manual QA (e.g., `1.1.0-pr-123.abc1234`). These snapshots are built only for apps that changed and include Docker images for API and Admin, and APK artifacts for the Client.

  ## Domain Context

  The project focuses on consumables, implying a domain model that likely includes entities such as:

  - Consumable types (e.g., wine, beer, cheese, coffee, gin)
  - Specific consumable items
  - User ratings and reviews
  - Sharing functionalities
  - User profiles

  Understanding the nuances of different consumable categories and their associated attributes (e.g., vintage for wine, origin for coffee) will be crucial for development.

  ## Important Constraints

  - **Automated Releases:** The project heavily relies on automated release processes via Conventional Commits and versio. Adherence to commit message guidelines is critical.
  - **Monorepo Structure:** Development and tooling must respect the monorepo's organization and shared resources.
  - **Multi-platform:** The client application targets both mobile and web, requiring careful consideration of platform-specific behaviors and UI/UX.
  - **Private License:** The project is private, with all rights reserved.

  ## External Dependencies

  - **GitHub Actions:** For CI/CD pipelines, including workflows for version creation (`version.yml`), building and releasing from tags (`release.yml`), creating snapshot builds for QA (`pr-snapshot.yml`), and cleaning up old snapshots (`cleanup-snapshots.yml`).
  - **Docker Hub:** For publishing Docker images.
  - **Google Cloud Run:** For deploying API and admin panel.
  - **Cloud SQL:** For database services (MySQL).
  - **versio:** For automated versioning and changelogs.
  - **commitlint:** For enforcing conventional commit format.
  - **husky:** For Git hooks.
  - **Docker Compose:** For local development orchestration.

  ## Documentation Philosophy

  Documentation is organized by **purpose** rather than by app:

  - **Getting Started:** For new developers.
  - **Architecture:** For understanding system design.
  - **Features:** For cross-app functionality.
  - **Guides:** For accomplishing specific tasks.
  - **Component Docs:** For app-specific details.
  - **Operations:** For deployment and CI/CD.

  Documentation should be updated when new features are added, existing behavior changes, new API endpoints are introduced, environment variables are updated, deployment processes change, or dependencies are added/removed. It should be written in Markdown, include code examples and screenshots where appropriate, be concise and actionable, and link to related documentation. General features are documented in `docs/features/`, API-specific in `docs/api/`, Client-specific in `docs/client/`, Admin-specific in `docs/admin/`, Architecture in `docs/architecture/`, and Operations in `docs/operations/`.
